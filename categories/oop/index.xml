<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OOP on jackson.tmm</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/categories/oop/</link><description>Recent content in OOP on jackson.tmm</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 21 Mar 2022 13:41:34 +0800</lastBuildDate><atom:link href="https://ryantokmanmokmtm.github.io/personal-blogger/categories/oop/index.xml" rel="self" type="application/rss+xml"/><item><title>[筆記]設計模式之創建型模式-抽象工廠模式(Abstract Factory Pattern)</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/degsin-patter-abstractfactory/</link><pubDate>Mon, 21 Mar 2022 13:41:34 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/degsin-patter-abstractfactory/</guid><description>Question 什麼是抽象工廠模式(Abstract Factory Pattern) 定義
建立一個接口,讓子類自己決定實現哪一個Factory,承了Simple Factory Patterns的優點,同時解決了它的問題(新增產品需要修改Source)
參考來源:
csdn</description></item><item><title>[筆記]設計模式之創建型模式-工廠模式(Factory Pattern)</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-factory/</link><pubDate>Mon, 21 Mar 2022 13:27:56 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-factory/</guid><description>Question 什麼是工廠模式模式(Factory Pattern) 定義
建立一個接口,讓子類自己決定實現哪一個Factory,承了Simple Factory Patterns的優點,同時解決了它的問題(新增產品需要修改Source)
Tip 優點
Client無需知道Object的設置的細節，也無需知道實質Object的名稱，只需通過工廠即可 工廠(Factory)以及產品(Product)都是透過Polymorphism(多態)來實現，也是工廠模式的關鍵，工廠可以自主的決定要生產什麼產品，在內部進行設置產品(封裝在內部) 加入新的Product時無需修改Abstract class 以及 具體的工廠和產品的類，只要擴展新增即可，符合Open-Close principle Warning 缺點
新增產品時，要加入新的產品類以及工廠類，增加了系統的複雜度，而且需要從新編譯，增加了開銷 為了擴展性,加入了抽象類，Client都使用Abstract class 進行編程，增加了系統的抽象性和理解難度 Example 注意:以下程式單純用於講解當前設計模式,並不能運行
//Factory 透過Abstract來繼承/實現 //logger 的🌰 //Abstract Logger class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc.</description></item><item><title>[筆記]設計模式之創建型模式-簡單工廠模式(Simple Factory Pattern)</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-simplefactory/</link><pubDate>Mon, 21 Mar 2022 13:05:53 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-simplefactory/</guid><description>Question 什麼是簡單工廠模式(Simple Factory Pattern)
提供一種建立類的方式同時隱藏內部logic的方式
注意: 簡單工廠不在23個設計模式之內 定義 建立一個接口,讓子類自己決定實現哪一個Factory,其重點在於工廠，透過工廠的Static method 進行Product(繼承於同一Abstract)的Object
Warning 缺點:
不符合Open-Close Principe(新增產品必須修改工廠) Example 注意:以下程式單純用於講解當前設計模式,並不能運行
透過傳入參數到Factory 類進行不同類別的生成，但是如果要生成更多的類別,就必要要修改Factory類,違反Open-Close 原則
class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == &amp;#34;A&amp;#34;){ return new ProductA(); } else if(type == &amp;#34;B&amp;#34;){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct(&amp;#34;A&amp;#34;); //get ProductA instance Product* B = Factory::getProduct(&amp;#34;B&amp;#34;); //get ProductB instance } 參考來源:</description></item><item><title>[筆記]設計模式-原則</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-spc/</link><pubDate>Mon, 21 Mar 2022 13:00:27 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-spc/</guid><description>Design Patterns(設計模式) 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。
設計模式是描述在各種不同的情況下，如何解決問題的一種方案。
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。
設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
原則(Principe) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe) 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) 創建式(6個) 模式(Patterns) 簡單描述(Simple description) 簡單工廠模式(Simple Factory Pattern) 使用一個對象建立不同的對象,Client 傳入1個String 返回一個對象 工廠模式(Factory Pattern) 解決SFP的問題(單一原則),改為一個工廠生產一個對象 抽象工廠模式(Abstract Factory Pattern) 把產品分類，同類型的都由一個工廠生產 單例模式(Singleton Pattern) 一個系統只提供提個實例對象(Static) 原形模式(Prototype Pattern) 提供方法(Clone)方法,透過複製自己(注意Deep/Shallow Clone)，產生相同的對象 建立者模式(Builder Pattern) 對象的建立有一個特定建立的過程不同的build方法(如角色的創建)，適用與創建過程相似的Product 結構型模式(7個) 模式(Patterns) 簡單描述(Simple description) 適配器模式(Adapter Pattern) 透過Adapter 去適配不兼容的API/接口(如名字不符合目前應用等) 橋接模式(Bridge Pattern) 取代多層繼承帶來的新增具體類數量的問題,把繼承分開多個獨立維度對象,獨立變化,每個維度在透過橋接(注入的方法)進行結合 組合模式(Composite Pattern) 主要處理的對象為Tree 結構的對象 Node跟Left的處理方法不一樣,這個模式可以讓Client一致對待Leaf和Node 裝飾模式(Decorator Pattern) 主要是解決對象複用問題,透過裝飾類對基本的對象進行一次或者多次處理裝飾,使用關聯取代繼承,給對象新增額外的職責 外觀模式(Facade Pattern) 主要解決的時候給Client 與 一個或者多個Sub-system 提供一個統一的入口,減低Client與Sub-system的溝通與系統的複雜程度 享元模式(FlayWeight Pattern) 主要解決的問題分享有相同內部不變的狀態的對象,無需重新新增新的而且具有相同的對象,而會隨著環境改變的狀態,不會存在對象裡,所以不會影響到對象的內部 代理模式(Proxy Pattern) 主要解決的問題為Client與對象之間提供一個中介(代理)進行不同的操作。(5種常用的代理模式) 常用的代理模式</description></item></channel></rss>