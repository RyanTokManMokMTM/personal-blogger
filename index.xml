<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jackson.tmm</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/</link><description>Recent content on jackson.tmm</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 21 Mar 2022 13:41:34 +0800</lastBuildDate><atom:link href="https://ryantokmanmokmtm.github.io/personal-blogger/index.xml" rel="self" type="application/rss+xml"/><item><title>[筆記]設計模式之創建型模式-抽象工廠模式(Abstract Factory Pattern)</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/degsin-patter-abstractfactory/</link><pubDate>Mon, 21 Mar 2022 13:41:34 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/degsin-patter-abstractfactory/</guid><description>Question 什麼是抽象工廠模式(Abstract Factory Pattern) 定義
建立一個接口,讓子類自己決定實現哪一個Factory,承了Simple Factory Patterns的優點,同時解決了它的問題(新增產品需要修改Source)
參考來源:
csdn</description></item><item><title>[筆記]設計模式之創建型模式-工廠模式(Factory Pattern)</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-factory/</link><pubDate>Mon, 21 Mar 2022 13:27:56 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-factory/</guid><description>Question 什麼是工廠模式模式(Factory Pattern) 定義
建立一個接口,讓子類自己決定實現哪一個Factory,承了Simple Factory Patterns的優點,同時解決了它的問題(新增產品需要修改Source)
Tip 優點
Client無需知道Object的設置的細節，也無需知道實質Object的名稱，只需通過工廠即可 工廠(Factory)以及產品(Product)都是透過Polymorphism(多態)來實現，也是工廠模式的關鍵，工廠可以自主的決定要生產什麼產品，在內部進行設置產品(封裝在內部) 加入新的Product時無需修改Abstract class 以及 具體的工廠和產品的類，只要擴展新增即可，符合Open-Close principle Warning 缺點
新增產品時，要加入新的產品類以及工廠類，增加了系統的複雜度，而且需要從新編譯，增加了開銷 為了擴展性,加入了抽象類，Client都使用Abstract class 進行編程，增加了系統的抽象性和理解難度 Example 注意:以下程式單純用於講解當前設計模式,並不能運行
//Factory 透過Abstract來繼承/實現 //logger 的🌰 //Abstract Logger class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc.</description></item><item><title>[筆記]設計模式之創建型模式-簡單工廠模式(Simple Factory Pattern)</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-simplefactory/</link><pubDate>Mon, 21 Mar 2022 13:05:53 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-simplefactory/</guid><description>Question 什麼是簡單工廠模式(Simple Factory Pattern)
提供一種建立類的方式同時隱藏內部logic的方式
注意: 簡單工廠不在23個設計模式之內 定義 建立一個接口,讓子類自己決定實現哪一個Factory,其重點在於工廠，透過工廠的Static method 進行Product(繼承於同一Abstract)的Object
Warning 缺點:
不符合Open-Close Principe(新增產品必須修改工廠) Example 注意:以下程式單純用於講解當前設計模式,並不能運行
透過傳入參數到Factory 類進行不同類別的生成，但是如果要生成更多的類別,就必要要修改Factory類,違反Open-Close 原則
class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == &amp;#34;A&amp;#34;){ return new ProductA(); } else if(type == &amp;#34;B&amp;#34;){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct(&amp;#34;A&amp;#34;); //get ProductA instance Product* B = Factory::getProduct(&amp;#34;B&amp;#34;); //get ProductB instance } 參考來源:</description></item><item><title>[筆記]設計模式-原則</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-spc/</link><pubDate>Mon, 21 Mar 2022 13:00:27 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/design-pattern-spc/</guid><description>Design Patterns(設計模式) 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。
設計模式是描述在各種不同的情況下，如何解決問題的一種方案。
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。
設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
原則(Principe) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe) 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) 創建式(6個) 模式(Patterns) 簡單描述(Simple description) 簡單工廠模式(Simple Factory Pattern) 使用一個對象建立不同的對象,Client 傳入1個String 返回一個對象 工廠模式(Factory Pattern) 解決SFP的問題(單一原則),改為一個工廠生產一個對象 抽象工廠模式(Abstract Factory Pattern) 把產品分類，同類型的都由一個工廠生產 單例模式(Singleton Pattern) 一個系統只提供提個實例對象(Static) 原形模式(Prototype Pattern) 提供方法(Clone)方法,透過複製自己(注意Deep/Shallow Clone)，產生相同的對象 建立者模式(Builder Pattern) 對象的建立有一個特定建立的過程不同的build方法(如角色的創建)，適用與創建過程相似的Product 結構型模式(7個) 模式(Patterns) 簡單描述(Simple description) 適配器模式(Adapter Pattern) 透過Adapter 去適配不兼容的API/接口(如名字不符合目前應用等) 橋接模式(Bridge Pattern) 取代多層繼承帶來的新增具體類數量的問題,把繼承分開多個獨立維度對象,獨立變化,每個維度在透過橋接(注入的方法)進行結合 組合模式(Composite Pattern) 主要處理的對象為Tree 結構的對象 Node跟Left的處理方法不一樣,這個模式可以讓Client一致對待Leaf和Node 裝飾模式(Decorator Pattern) 主要是解決對象複用問題,透過裝飾類對基本的對象進行一次或者多次處理裝飾,使用關聯取代繼承,給對象新增額外的職責 外觀模式(Facade Pattern) 主要解決的時候給Client 與 一個或者多個Sub-system 提供一個統一的入口,減低Client與Sub-system的溝通與系統的複雜程度 享元模式(FlayWeight Pattern) 主要解決的問題分享有相同內部不變的狀態的對象,無需重新新增新的而且具有相同的對象,而會隨著環境改變的狀態,不會存在對象裡,所以不會影響到對象的內部 代理模式(Proxy Pattern) 主要解決的問題為Client與對象之間提供一個中介(代理)進行不同的操作。(5種常用的代理模式) 常用的代理模式</description></item><item><title>[畢業專題]IOS-電影App</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/projects/ios-app/</link><pubDate>Mon, 21 Mar 2022 11:56:12 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/projects/ios-app/</guid><description>項目地址 OTT電影推薦平台-IOS Client
功能 簡介 用戶基本功能 登入/註冊/登出等基本功能 推薦電影 以卡片的形式呈現電影 宣傳片推薦 以全屏影片的方式推薦電影 類型搜尋 分成了電影類型,演員類型以及導演類型 文字搜尋 基本的文字搜尋電影 電影詳細介紹 顯示相關電影的資訊:介紹,演員,導演等 喜好列表 用戶可以加入電影至自己喜歡的電影 前端 使用工具與技術
SwiftUI apple framework UIKit apple framework 後端 使用工具與技術
Vapor Swift Backend framework PostgresSQL Database 新增的功能 完善使用者個人頁面 - UI設計參考 小紅書APP</description></item><item><title>Algorithm Traning</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/algorithm-traning/</link><pubDate>Sun, 20 Mar 2022 19:47:42 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/algorithm-traning/</guid><description>Planning&amp;hellip;</description></item><item><title>About</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/about/</link><pubDate>Sun, 20 Mar 2022 19:46:32 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/about/</guid><description>Sorry about my bad English, I&amp;rsquo;m trying to use the English to make this website in order to impove my English skill.
If you have found some mistakes,please me know :(
Hello, welcome to my website. This page is all about me. If you are interested in me,please keep reading. You can contact me by the following link bellow:
Email @Jacksontmm in Telegram Personal&amp;rsquo;s introducation My Given name is TokMan and my Surname is Mok,you can call me Jackson.</description></item><item><title>簡易聊天室</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/simple-tcp-chatroom-ch/</link><pubDate>Sat, 19 Mar 2022 13:17:18 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/simple-tcp-chatroom-ch/</guid><description>簡易聊天室 實作的主要目的是熟悉go語言的並發機制
TCP Server 實作 User Structure 用於記錄已連接到TCP Server是信息
type User struct { ID int Addr string EnterAt time.Time MessageChan chan string //individual user channel } Message Structure 用於傳送信息且跳過/無視發送者自己
type Message struct { Owner int Msg string } 3個goroutine(concurrency)
enterChannel = make(chan *User) 用於給全部user發送新用戶進入聊天室.
leavingChannel = make(chan *User) 作用與 enterChannel一樣,但用於用戶離開聊天室之信息
messageChannel = make(chan Message, 8) 用於用戶與用戶之間的通訊
main function 在localhost:8080建立一個TCP Server 建立一個goroutine 用於廣播 使用無限迴圈用於等待與接收連接TCP的用戶 func main() { //open a TCP Server listen, err := net.</description></item><item><title>simple-TCP-Chatroom</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/simple-tcp-chatroom/</link><pubDate>Sat, 19 Mar 2022 13:08:48 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/simple-tcp-chatroom/</guid><description>simpleChatRoom Playing/Learning goroutine by making a simple char room with TCP
TCP Server implementation User Structure is used to record user info that connected to the TCP Server
type User struct { ID int Addr string EnterAt time.Time MessageChan chan string //individual user channel } Message Structure is used to ignore the user who sends the message to others
type Message struct { Owner int Msg string } Three gorouitne(concurrency)</description></item><item><title>Go並發-電影API爬蟲</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/projects/movie-webcrawler/</link><pubDate>Fri, 01 Oct 2021 12:22:43 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/projects/movie-webcrawler/</guid><description/></item><item><title>基於虛幻4的BullsAndCows遊戲</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/projects/unreal-bullsandcows/</link><pubDate>Sun, 09 Aug 2020 12:24:21 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/projects/unreal-bullsandcows/</guid><description/></item><item><title>Projects</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/projects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/projects/</guid><description>Project is preparing&amp;hellip;sorry&amp;hellip; coming soon&amp;hellip;</description></item></channel></rss>