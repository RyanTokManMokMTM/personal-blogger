<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>jackson.tmm</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/</link><description>Recent content on jackson.tmm</description><generator>Hugo -- gohugo.io</generator><language>ch</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sun, 27 Mar 2022 16:55:17 +0800</lastBuildDate><atom:link href="https://ryantokmanmokmtm.github.io/personal-blogger/index.xml" rel="self" type="application/rss+xml"/><item><title>[Note]Creational-Factory</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notecreational-factory/</link><pubDate>Sun, 27 Mar 2022 16:55:17 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notecreational-factory/</guid><description>什麼是Factory(工廠)呢? 定義:建立一個接口,讓子類自己決定實現哪一個Factory,其重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題
簡單例子 注: 以及程式單純用於解釋，並不能實際執行
可透過子類繼承Factory的抽象類自主決定生產什麼樣的Product。 生產的Product在透過里氏替換原則(Lisko Subsititution princeple)替換成繼承與Logger的子類，即可換成的需要的Logger。 class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc.</description></item><item><title>[Note]Creational-Simple Factory</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notecreational-simple-factory/</link><pubDate>Sun, 27 Mar 2022 16:42:45 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notecreational-simple-factory/</guid><description>什麼是Simple Factory(簡單工廠)呢? 簡單而言就是: 由一個工廠來生產全部產品 定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object
簡單例子 注: 以及程式單純用於解釋，並不能實際執行
透過Factory 類的Static 方法調用方法，傳入參數生成相關的Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == &amp;#34;A&amp;#34;){ return new ProductA(); } else if(type == &amp;#34;B&amp;#34;){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct(&amp;#34;A&amp;#34;); //get ProductA instance Product* B = Factory::getProduct(&amp;#34;B&amp;#34;); //get ProductB instance } 優點 Client可以自行決定生產哪個Product Client免除直接建立Product的責任，只僅僅消費產品 Client無需關心具體的類名與相關設置參數 缺點 Factory 的職責太重。所有的Product 都由一個Object 生產，一旦不能正常工作，便會影響整個系統的運作 如有不同的Product會增加系統中的class的數目，增加了系統複雜度以及理解難度 擴展十分困難，添加需要修改Factory的邏輯。如果生存的Product較多時，可能會使其邏輯過於複雜，不利於系統的擴展與維護 違背原則 違背了Open-Close Principe 如果有新的Product 需要生成，就必修要修改Factory類 參考資料:</description></item><item><title>[Note]Design Pattern Princeple</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notedesign-pattern-princeple/</link><pubDate>Sun, 27 Mar 2022 16:18:55 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notedesign-pattern-princeple/</guid><description>什麼是Design Pattern(設計模式)呢? 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，如何解決問題的一種方案
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。 設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
Design Pattern 有什麼原則呢? 原則(Princeple) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) Design Pattern 分成哪幾種呢?</description></item><item><title>[Note]What Is JWT(Json Web Token)-EN</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notewhat-is-jwtjson-web-token-en/</link><pubDate>Thu, 24 Mar 2022 13:52:49 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notewhat-is-jwtjson-web-token-en/</guid><description>What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&amp;rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:</description></item><item><title>About me</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/about/</link><pubDate>Tue, 22 Mar 2022 19:32:50 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/about/</guid><description>Sorry about my bad English :(
Introduction Hello, welcome to my website. This page is all about me. If you are interested in me, keep reading or you can contact me by the following link bellow:
Email @Jacksontmm in Telegram My name is Jackson. I am a year 4 student who studies Computer Science And Information Engineering at Changgeng University in Taiwan. During my university life, I have tried a lot of different things other than my major.</description></item><item><title>[CGU]Graduation Project</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/projects/final-project/</link><pubDate>Fri, 31 Dec 2021 20:22:11 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/projects/final-project/</guid><description>OTT Movies recommender system-IOS Client
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database</description></item></channel></rss>