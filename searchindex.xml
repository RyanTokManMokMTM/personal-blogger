<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>[Note]Creational-Factory</title><url>https://ryantokmanmokmtm.github.io/personal-blogger/post/creational-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Factory(工廠)呢? 定義:建立一個接口,讓子類自己決定實現哪一個Factory,其重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題
簡單例子 注: 以及程式單純用於解釋，並不能實際執行
可透過子類繼承Factory的抽象類自主決定生產什麼樣的Product。 生產的Product在透過里氏替換原則(Lisko Subsititution princeple)替換成繼承與Logger的子類，即可換成的需要的Logger。 class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc... Logger* logger = new DatabaseLogger(); //init this logger etc... return logger } } //Client to use int main(){ Factory *factory = new FileLoggerFactory(); Logger *logger = factory->createLogger(); //return the Product that it is initialized Logger->wirteLog(); return; //如果想讓系統有更多靈活性和課擴展性，可以透過xml來進行配置，不需透過修過client的代碼 //只需更新xml中的設置，在代碼中新增新的Product 以及新增的Factory 並重新編譯便可 //除了默認的設置方法外，還想透過傳入String的方法來自定義設計，例如連接要DB，文件的路徑等等 //可以透過Override Abstruct class 的func來進行設置 /* class Factory{ public: virtual Logger* createLogger() = 0; virtual Logger* createLogger(string config) = 0; virtual Logger* createLogger(Object obj) = 0;//通過Obj裡面的成員進行設置等 } */ } 優點 Client無需知道Object的設置的細節，也無需知道實質Object的名稱，只需通過工廠即可 工廠(Factory)以及產品(Product)都是透過Polymorphism(多態)來實現，也是工廠模式的關鍵，工廠可以自主的決定要生產什麼產品，在內部進行設置產品(封裝在內部) 加入新的Product時無需修改Abstract class 以及 具體的工廠和產品的類，只要擴展新增即可，符合Open-Close principle 透過繼承抽象類使系統更容易擴展 缺點 新增產品時，要加入新的產品類以及工廠類，增加了系統的複雜度，而且需要從新編譯，增加了開銷 為了擴展性,加入了抽象類，Client都使用Abstract class 進行編程，增加了系統的抽象性和理解難度 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Creational-Simple Factory</title><url>https://ryantokmanmokmtm.github.io/personal-blogger/post/creational-simple-factory/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>creational</tag><tag>learning</tag></tags><content type="html"> 什麼是Simple Factory(簡單工廠)呢? 簡單而言就是: 由一個工廠來生產全部產品 定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object
簡單例子 注: 以及程式單純用於解釋，並不能實際執行
透過Factory 類的Static 方法調用方法，傳入參數生成相關的Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == "A"){ return new ProductA(); } else if(type == "B"){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct("A"); //get ProductA instance Product* B = Factory::getProduct("B"); //get ProductB instance } 優點 Client可以自行決定生產哪個Product Client免除直接建立Product的責任，只僅僅消費產品 Client無需關心具體的類名與相關設置參數 缺點 Factory 的職責太重。所有的Product 都由一個Object 生產，一旦不能正常工作，便會影響整個系統的運作 如有不同的Product會增加系統中的class的數目，增加了系統複雜度以及理解難度 擴展十分困難，添加需要修改Factory的邏輯。如果生存的Product較多時，可能會使其邏輯過於複雜，不利於系統的擴展與維護 違背原則 違背了Open-Close Principe 如果有新的Product 需要生成，就必修要修改Factory類 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]Design Pattern Princeple</title><url>https://ryantokmanmokmtm.github.io/personal-blogger/post/design-pattern-princeple/</url><categories><category>programming</category><category>design pattern</category></categories><tags><tag>learning</tag><tag>note</tag></tags><content type="html"> 什麼是Design Pattern(設計模式)呢? 設計模式(Design Pattern) 是對軟體設計中普遍存在（反覆出現）的各種問題，所提出的解決方案。用於描述在各種不同的情況下，如何解決問題的一種方案
OOP設計模式通常以類別或者物件來描述關係和相互的作用(不涉及完成應用的特定object)。 設計模式能使不穩定依賴於相對穩定、具體依賴於相對抽象，避免會引起麻煩的緊耦合。
Design Pattern 有什麼原則呢? 原則(Princeple) 定義(Def) 單一職責原則(Single Responsibility Principle) 一個類只負責一個功能領域中的相應的原則 開閉原則(Open-Closed Principle) 對擴展開發(可以繼承擴展)，對修改關閉(不能修改BaseClass) 里氏替換原則(Liskov Substitution Principe) 所有引用於Base Class 的地方 都能夠透明的使用其子類的對象(以子類來替換父類) 依賴倒轉原則(Dependencie Inversion Principe 細節應依賴於抽象(Abstract),抽象(Abstract)不應該依賴與細節。(也就是細節由子類來實現，父類負責定義) 接口隔離原則(Interface Segregation Principle) 使用多個專用的接口(Interface),而不是使用單一的總接口.(能避免Client實現一些沒必要的功能) 合成複用原則(Composition Reuse Principle) 盡量使用Object Composition(在要使用的Object的地方把用到的Object注入),而不是繼承能達到目的.(減少依賴) 迪米特法則(Law of Demeter) 一個軟件實體應盡可能地與其他實體發生互相作用.(就是不用跟不是朋友(注入)的Object 直接通訊) Design Pattern 分成哪幾種呢? 主要分成3大類，一共23個
創建型模式(6個) 結構型模式(7個) 行為型模式(11個) 創建型模式(6個) 簡單工廠模式(Simple Factory Pattern) 工廠模式(Factory Pattern) 抽象工廠模式(Abstract Factory Pattern) 單例模式(Singleton Pattern) 原形模式(Prototype Pattern) 建立者模式(Builder Pattern) 結構型模式(7個) 適配器模式(Adapter Pattern) 橋接模式(Bridge Pattern) 組合模式(Composite Pattern) 裝飾模式(Decorator Pattern) 外觀模式(Facade Pattern) 享元模式(FlayWeight Pattern) 代理模式(Proxy Pattern) 行為型模式(11個) 職責鏈模式(Chain of Responsibility Pattern) 命令模式(Command Pattern) 解釋器模式(Interpreter Pattern) 迭代器模式(Iterator Pattern) 中介者模式(Mediator Pattern) 備忘錄模式(Memento Pattern) 觀察者模式(Observer Pattern) 狀態模式(State Pattern) 策略模式(Strategy Pattern) 板塊模式(Template Method Pattern) 訪問者模式(Visitor Pattern) 參考資料:
史上最全设计模式导学目录（完整版）</content></entry><entry><title>[Note]What Is JWT(Json Web Token)-EN</title><url>https://ryantokmanmokmtm.github.io/personal-blogger/post/jwt-note/</url><categories><category>backend</category><category>development</category><category>web develpment</category><category>note</category><category>english</category></categories><tags><tag>web develpment</tag><tag>token</tag></tags><content type="html"> What is JWT(Json Web Token)? The full name of JWT is Json Web Token. Acccording to the definition, JWT is a proposed Internet standard for creating data with optinal signature and/or opntional encryption whose payload holds JSON that asserts some number of clamis.
It&rsquo;s used for identity authentication between client and the server that allows accessing resources in the server.
The Structure of JWT JWT consists of three parts including:
Header Payload Signature JWT Header Header typically consists of two parts
type : what&rsquo;s the type of the token algorithm : what algorithm does this token use to sign/encrypt. such as SHA256,RAS or HMAC { "typ" : "jwt", "alg" : "HS256" } This information will be encoded by base64Url algorithm in order to generate the JWT Header
JWT payload In payload is typically saving some users information and other useful information.
Be carefulthat payload must not include any secret information due to base64Url algorithm is easy to be decrypted.
JWT Payload standard claims
{ "sub" :"",//subject "aud" :"",//audience "jti" :"",//jwt id "iat" :"",//Issued at "iss" :"",//Issuer - who is the publisher of the jwt "nbf" :"",//Not Before - JWT is not available before the time jwt set. // other user information that developer set //for example: "user_name" : "jackson_tmm", "email" : "admin@admin.com" } This information will be encoded by base64Url algorithm in order to generate the JWT Payload
Signature The Signature is used to authenticate whether information has been modified during transmission and authenticate the sender that sent this JWT.
To Generate JWT Token Following this function
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), your-256-bit-secret) And these three partes will be combined by a . as following format: xxx.yyy.zzz
//exmaple eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ How it work between Client and server sequenceDiagram Client-Server:POST /authentication {username:xxx..} Note over Client,Server: User logs in alt is authenticated Server-Client:HTTP Status:200 {"token":eyxxx.xx.x} Note over Server,Client: Loged in Succeed else Unauthorized Server-Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Loged in Failed end Client-Server: POST /user/profile {"Authorization":"Bear token"} Note over Server,Client: Get User Profile with token alt succeed Server--Client: HTTP Status:200 {"profile":eyxxx.xx.x} Note over Server,Client: Succeed and response a profile else Unauthorized Server--Client: HTTP Status:401 {"msg":xxx} Note over Server,Client: Unauthorized(token error) end</content></entry><entry><title>[CGU]Graduation Project</title><url>https://ryantokmanmokmtm.github.io/personal-blogger/project/final-project/</url><categories><category>development</category><category>project</category><category>apple</category></categories><tags><tag>ios-app</tag><tag>app-dev</tag></tags><content type="html"> OTT Movies recommender system-IOS Client
Frontend SwiftUI apple framework UIKit apple framework Backend Vapor Swift Backend framework Database: PostgresSQL Database</content></entry><entry><title>支持Emoji表情符号</title><url>https://ryantokmanmokmtm.github.io/personal-blogger/post/emoji-support/</url><categories/><tags><tag>emoji</tag></tags><content type="html"> 在Hugo项目中可以通过多种方式启用Emoji。
The emojify function can be called directly in templates or Inline Shortcodes.
To enable emoji globally, set enableEmoji to true in your site&rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.
馃檲 🙈 馃檳 🙉 馃檴 🙊
The Emoji cheat sheet is a useful reference for emoji shorthand codes.
N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.
.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }</content></entry><entry><title>关于我</title><url>https://ryantokmanmokmtm.github.io/personal-blogger/about.html</url><categories/><tags/><content type="html"> Hugo是用Go编写的一个开放源代码静态站点生成器，可在Apache许可证2.0下使用。 Hugo支持TOML, YAML和JSON数据文件类型，Markdown和HTML内容文件，并使用短代码添加丰富的内容。其他值得注意的功能包括分类法、多语言模式、图像处理、自定义输出格式、HTML/CSS/JS缩小和对Sass SCSS工作流的支持。
Hugo使用了多种开源项目，包括:
https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo是博客、企业网站、创意作品集、在线杂志、单页应用程序甚至是数千页的网站的理想选择。
Hugo适合那些想要手工编写自己的网站代码，而不用担心设置复杂的运行时、依赖关系和数据库的人。
使用Hugo建立的网站非常快速、安全，可以部署在任何地方，包括AWS、GitHub Pages、Heroku、Netlify和任何其他托管提供商。
更多信息请访问GitHub.</content></entry></search>