<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>creational on jackson.tmm</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/tags/creational/</link><description>Recent content in creational on jackson.tmm</description><generator>Hugo -- gohugo.io</generator><language>ch</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sun, 27 Mar 2022 16:55:17 +0800</lastBuildDate><atom:link href="https://ryantokmanmokmtm.github.io/personal-blogger/tags/creational/index.xml" rel="self" type="application/rss+xml"/><item><title>[Note]Creational-Factory</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notecreational-factory/</link><pubDate>Sun, 27 Mar 2022 16:55:17 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notecreational-factory/</guid><description>什麼是Factory(工廠)呢? 定義:建立一個接口,讓子類自己決定實現哪一個Factory,其重點是繼承了Simple Factory Patterns的優點,同時解決了它的問題
簡單例子 注: 以及程式單純用於解釋，並不能實際執行
可透過子類繼承Factory的抽象類自主決定生產什麼樣的Product。 生產的Product在透過里氏替換原則(Lisko Subsititution princeple)替換成繼承與Logger的子類，即可換成的需要的Logger。 class Logger{ public: virtual void wirteLog() = 0; } //Implement class DatabaseLogger: public Logger{ pubic: void wirteLog(){ //Wirte DB log message } } class FileLogger : public Logger{ public: void wirteLog(){ //Write File Log message } } //Abstruct Factory class Factory{ public: virtual Logger* createLogger() = 0; } //不可以是Static靜態，因為子類是動態實現父類的函數(static 沒有this指標) //Implement class FileLoggerFactory : public Factory{ public: Logger* createLogger(){ //init file logger //TODO init etc //create file logger Logger* logger = new FileLogger(); //TODO Create file etc return Logger; } } class DabatabaseFactory : public Factory{ public: Logger* createLogger(){ //Connect to db //Create db logger etc.</description></item><item><title>[Note]Creational-Simple Factory</title><link>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notecreational-simple-factory/</link><pubDate>Sun, 27 Mar 2022 16:42:45 +0800</pubDate><guid>https://ryantokmanmokmtm.github.io/personal-blogger/posts/2022/03/notecreational-simple-factory/</guid><description>什麼是Simple Factory(簡單工廠)呢? 簡單而言就是: 由一個工廠來生產全部產品 定義:建立一個接口,讓子類自己決定實現哪一個Factory,重點在於工廠，透過工廠的Static method 進行生成的Object
簡單例子 注: 以及程式單純用於解釋，並不能實際執行
透過Factory 類的Static 方法調用方法，傳入參數生成相關的Product class Product{ public: virtual void someMethod() = 0 } class ProductA : public Product{ public: void someMethod(){ //TODO For ProductA } } class ProductB : Public Product{ public: void someMethod(){ //TODO for ProductB } } class Factory{ public: static Product* getProduct(string type){ if(type == &amp;#34;A&amp;#34;){ return new ProductA(); } else if(type == &amp;#34;B&amp;#34;){ return new ProductB(); } return null; } } int main(){ Product* A = Factory::getProduct(&amp;#34;A&amp;#34;); //get ProductA instance Product* B = Factory::getProduct(&amp;#34;B&amp;#34;); //get ProductB instance } 優點 Client可以自行決定生產哪個Product Client免除直接建立Product的責任，只僅僅消費產品 Client無需關心具體的類名與相關設置參數 缺點 Factory 的職責太重。所有的Product 都由一個Object 生產，一旦不能正常工作，便會影響整個系統的運作 如有不同的Product會增加系統中的class的數目，增加了系統複雜度以及理解難度 擴展十分困難，添加需要修改Factory的邏輯。如果生存的Product較多時，可能會使其邏輯過於複雜，不利於系統的擴展與維護 違背原則 違背了Open-Close Principe 如果有新的Product 需要生成，就必修要修改Factory類 參考資料:</description></item></channel></rss>